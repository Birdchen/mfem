This directory contains an initial reference implementation of different finite
element assembly and evaluation algorithms targeting high-performance for
high-order elements on modern hardware.

Following is a short description of each file.

makefile
   By default "make" builds the test driver (see below) with the compiler used
   to compile MFEM. If g++ was used, a pseudo-code dump file with the optimized
   code will be generated (option "-fdump-tree-optimized-blocks"). The g++
   option "--param max-completely-peel-times=3" prevents the compiler from
   unrolling innermost loops (of size >= 4), allowing the compiler to vectorize
   them. Use "make test.s" to compile to assembler code. Some options for
   optimization/vectorization with the clang compiler are also included.

config.hpp
   Config macros including the specification of the template blocking size
   (currently used in the matrix-matrix multiply).

layouts.hpp
   Classes describing fixed size tensor layouts.  Implemented are standard
   strided layouts for 1D/2D/3D/4D tensors.  Layouts support reshape and
   sub-tensor operations independent of the actual data storage.

assign_ops.hpp
   Helper templated function to allow single implementation of multiple
   assignment operations on tensor entries.

small_matrix_ops.hpp
   Small matrix operations, defined by specializations: determinant, adjugate,
   etc.

tensor_ops.hpp
   Element-wise tensor operations: A {=,+=,*=} scalar; A {=,+=,*=} B.  The
   latter allows different input and output layouts. With suitable layouts this
   can be used to permute (transpose) tensors, extract sub-tensors, etc.

tensor_types.hpp
   Fixed-size container classes TVector, TMatrix, TTensor3, TTensor4 for
   1D/2D/3D/4D tensors stored in column-major layout.

matrix_products.hpp
   Matrix-matrix multiply, C = A.B, simple and blocked version.

tensor_products.hpp
   The tensor contraction/product operations:
   - Mult_1_2: C_{i,j,k}  {=|+=}  \sum_s A_{s,j} B_{i,s,k}
   - Mult_2_1: C_{i,j,k}  {=|+=}  \sum_s A_{i,s} B_{s,j,k}
   - TensorAssemble: C_{i,k,j,l}  {=|+=}  A_{s,i} A_{s,j} B_{k,s,l}

finite_elements_h1.hpp
   H1 finite elements templated by geometry (triangles, quads, etc.) and
   polynomial order.

integration_rules.hpp
   Quadrature rules templated by geometry (see above) and integration order.

shape_evaluators.hpp
   Classes for evaluating basis functions and their derivatives at quadrature
   points, templated by a finite element class and an integration rule class.
   Quads and hexes use the tensor-product structure for fast evaluation.

vector_layouts.hpp
   Classes for converting scalar data indices into multi-component (vector) data
   indices. This is used to describe the layout of vector GridFunctions on
   global degrees of freedom (similar to the Ordering class).

fespace_h1.hpp
fespace_l2.hpp
   FiniteElementSpace classes providing the mappings between global and local
   (element) degrees of freedom for H1 continuous and L2 discontinuous spaces.

mass_operator.hpp
   Implementation of a finite element mass matrix operator, TMassOperator, using
   various assembly/evaluation schemes:
   - MultUnassembled: matrix-free action using the mesh nodes and the input
     vector.
   - Assemble, MultAssembled: partial assembly and operator action using the
     partially assembled data at quadrature points and the input vector.
   - AssembleMatrix(DenseTensor &): assemble the local element matrices and
     store them as DenseTensor.
   - AssembleMatrix(SparseMatrix &): assemble the operator in a global (CSR)
     SparseMatrix.

test.cpp
   Test driver timing the various methods of TMassOperator for any type of
   geometry, solution space order, integration rule order, and mesh order.
