
Description of the experimental code
------------------------------------

The experimental code is in mfem/dev in the performance-dev branch of MFEM.

Contents of the experimental code:

 1. Implementation

   a) tmatrix.hpp - a dense matrix class template:

         template <int Height, int Width> class TMatrix;

      The matrix data is part of the class (not a pointer to data).
      The header implements several basic matrix operations: such as
      matrix-matrix products (A.B, A^t.B, ...), determinant, adjugate, etc.

   b) tbasis.hpp - a tensor-product-basis class template:

         template <int Dim, int P, int Q, int N> class TensorProductBasis;

      The template parameters are:
         - Dim = spatial dimension
         - P   = polynomial degree
         - Q   = number of quadrature points in one spatial direction
         - N   = number of entries (elements/fields/field-components) to process
                 at a time

      The purpose of this class is: given DOF (degrees of freedom) data on an
      element, compute values and/or derivatives at quadrature points. It uses
      the tensor product structure of the basis and the quadrature points to
      do the computations in an efficient manner.

      The input/output DOF data can be specified directly as a sequential local
      array, or indirectly through a global data array and a local array with
      indices (offsets in the global array).

   c) tinteg.hpp - two "integrator" class templates

         template <int Dim, int N> class TMassIntegrator;
         template <int Dim, int N> class TDiffusionIntegrator;

      for mass and diffusion matrix "assembly".

      The template parameters are:
         - Dim = spatial dimension
         - N   = number of quadrature points to process at a time

      The purpose of these classes is to define the "physics" computation at
      a qudrature point. The classes support two modes of operation: with and
      without assembly at quadrature points.

   d) tassembler.hpp - an "assembler" class

         template <class Integ, class Basis, bool isDG> class TAssembler;

      The template parameters are:
         - Integ = an "integrator" class
         - Basis = a "basis" class
         - isDG  = is the finite element space discontinous?

      The purpose of this class is to perform a matrix-vector product without
      assembling the matrix. The class has two modes of operation: with and
      without partial assembly. With partial assembly data associated with all
      quadrature points is pre-computed and stored.

      The "Integrator" and "Basis" classes use a set of "static const" fileds
      to describe their structure to "assembler" class(es).

      If parameter 'isDG' is true, the assembler can use "direct" data layout
      for the DOF data and call the "direct" methods of the "basis" class.

 2. Tests

   a) tmatrix-test.cpp - simlpe test measuring the performance of the
      matrix-matrix multiplication routines for class TMatrix. The test
      multiplies a matrix A with an array of matrices B[] and stores the result
      in another array of matrices C[]. All matrices are SxS with S defined at
      compile time. The size of the B[] and C[] arrays is such that each uses
      about 512 MiB.

      The code also tests MFEM's matrix-matrix multiplication where B[] and C[]
      are each viewed as one big matrix. If the macro TEST_EIGEN is defined,
      the test is also run using Eigen matrices and matrix-matrix products.

   b) tbasis-test.cpp - test the performance of the "direct" and "indirect"
      versions of the Calc and CalcT methods of TensorProductBasis which
      transform DOF data into qudrature point data and vice versa, respectively.
      The test uses DOF and quadrature point data arrays such that the larger
      of the two is about 1 GiB. The "indirect" methods use an indirection array
      that is filled with consecutive numbers.

   c) tassembler-test.cpp - test the performance of the TAssembler matrix-vector
      product and compare it with the performance of the same matrix-vector
      product using an assembled MFEM matrix in csr format. The comarison is
      done using mass and diffusion matrices on a continuous finite element
      space of given order -- thus the "indirect" versions of the
      TensorProductBasis methods are used.
