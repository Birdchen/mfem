This is a short description of the header files that are part of the initial
reference implementation of different finite element assembly and evaluation
algorithms in MFEM targeting high-performance for high-order elements on modern
hardware.

Following is a short description of each file.

miniapps/performance/makefile
   By default "make" builds the example drivers with the compiler used to
   compile MFEM. If g++ was used, a pseudo-code dump file with the optimized
   code will be generated (option "-fdump-tree-optimized-blocks"). The g++
   option "--param max-completely-peel-times=3" prevents the compiler from
   unrolling innermost loops (of size >= 4), allowing the compiler to vectorize
   them. Some options for optimization/vectorization with the clang compiler are
   also included.

config/tconfig.hpp
   Config macros including the specification of the template blocking size
   (currently used in the matrix-matrix multiply).

general/tassign.hpp
   Helper templated function to allow single implementation of multiple
   assignment operations on tensor entries.

linalg/tlayout.hpp
   Classes describing fixed size tensor layouts.  Implemented are standard
   strided layouts for 1D/2D/3D/4D tensors.  Layouts support reshape and
   sub-tensor operations independent of the actual data storage.
   Classes for converting scalar data indices into multi-component (vector) data
   indices. This is used to describe the layout of vector GridFunctions on
   global degrees of freedom (similar to the Ordering class).

linalg/tmatrix.hpp
   Small matrix operations, defined by specializations: determinant, adjugate,
   etc.
   Matrix-matrix multiply, C = A.B, simple and blocked version.

linalg/ttensor.hpp
   Fixed-size container classes TVector, TMatrix, TTensor3, TTensor4 for
   1D/2D/3D/4D tensors stored in column-major layout.
   Element-wise tensor operations: A {=,+=,*=} scalar; A {=,+=,*=} B.  The
   latter allows different input and output layouts. With suitable layouts this
   can be used to permute (transpose) tensors, extract sub-tensors, etc.
   The tensor contraction/product operations:
   - Mult_1_2: C_{i,j,k}  {=|+=}  \sum_s A_{s,j} B_{i,s,k}
   - Mult_2_1: C_{i,j,k}  {=|+=}  \sum_s A_{i,s} B_{s,j,k}
   - TensorAssemble: C_{i,k,j,l}  {=|+=}  A_{s,i} A_{s,j} B_{k,s,l}

fem/tfe.hpp
   H1 and L2 finite elements templated by geometry (triangles, quads, etc.) and
   polynomial order.

fem/tintrules.hpp
   Quadrature rules templated by geometry (see above) and integration order.

fem/tevaluator.hpp
   Classes for evaluating basis functions and their derivatives at quadrature
   points, templated by a finite element class and an integration rule class.
   Quads and hexes use the tensor-product structure for fast evaluation.
   // FieldEvaluator

fem/tfespace.hpp
   FiniteElementSpace classes providing the mappings between global and local
   (element) degrees of freedom for H1 continuous and L2 discontinuous spaces.

fem/tcoefficient.hpp
   TODO...

fem/teltrans.hpp
   TODO...

fem/tbilininteg.hpp
   TODO...
   mass kernel
   diffusion kernel

fem/tbilinearform.hpp
   TODO...

ex1.p/ex1p.cpp
   TODO...


[ DEPRECATED ]
fem/tmass_operator.hpp
   Implementation of a finite element mass matrix operator, TMassOperator, using
   various assembly/evaluation schemes:
   - MultUnassembled: matrix-free action using the mesh nodes and the input
     vector.
   - Assemble, MultAssembled: partial assembly and operator action using the
     partially assembled data at quadrature points and the input vector.
   - AssembleMatrix(DenseTensor &): assemble the local element matrices and
     store them as DenseTensor.
   - AssembleMatrix(SparseMatrix &): assemble the operator in a global (CSR)
     SparseMatrix.

